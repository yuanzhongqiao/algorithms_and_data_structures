## 数据结构和算法问题 Data Structure and Algorithms Problems

<center>

![alt tag](https://raw.githubusercontent.comhttps://github.com/yuanzhongqiao/algorithms_and_ds_playground/master/image.jpg)

| Current Status|     Stats     |
| :------------: | :----------: |
| Total C++ Problems | 188 |
| Total Python Problems | 15 |
| Current Daily Streak| 11 |
| Last Streak | 06/20/2019 - 06/21/2019|
| Current Streak | 06/23/2019 - 07/03/2019|

</center>


<div class="Box-sc-g0xbh4-0 bJMeLZ js-snippet-clipboard-copy-unpositioned" data-hpc="true"><article class="markdown-body entry-content container-lg" itemprop="text"><h2 tabindex="-1" dir="auto"><a id="user-content-data-structure-and-algorithms-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#data-structure-and-algorithms-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据结构与算法问题</font></font></h2>

<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.comhttps://github.com/yuanzhongqiao/algorithms_and_ds_playground/master/image.jpg"><img src="https://raw.githubusercontent.comhttps://github.com/yuanzhongqiao/algorithms_and_ds_playground/master/image.jpg" alt="替代标签" style="max-width: 100%;"></a></p>
<table>
<thead>
<tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前状态</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统计数据</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C++ 问题总数</font></font></td>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">188</font></font></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 问题总数</font></font></td>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前每日连胜</font></font></td>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后的连胜</font></font></td>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2019年6月20日 - 2019年6月21日</font></font></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前连胜</font></font></td>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2019年6月23日 - 2019年3月7日</font></font></td>
</tr>
</tbody>
</table>

<p dir="auto"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：这里的一些代码是旧的，是我学习 C++ 时编写的。</font><font style="vertical-align: inherit;">代码可能不安全或做出错误的假设。</font><font style="vertical-align: inherit;">请谨慎使用。</font><font style="vertical-align: inherit;">始终欢迎拉取请求。</font></font></strong></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-linkedlist-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#linkedlist-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链表问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到链表中倒数第n个节点。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/nthToLastNode.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nthToLastNode.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/nth_to_last_node.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nth_to_last_node.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加数字，其中数字的每个数字都由链表的节点表示。</font><font style="vertical-align: inherit;">以链接列表的形式给出输出。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/add_two_numbers_lists.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add_two_numbers_lists.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/add_two_numbers_lists.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add_two_numbers_list.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换链表的节点而不交换数据。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/swapNodesWithoutSwappingData.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swapNodesWithoutSwappingData.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/swap_nodes_without_swapping_data.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swap_nodes_without_swapping_data.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以迭代和递归方式反转链表</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/reverseLinkedListIterAndRecurse.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verseLinkedListIterAndRecurse.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/reverse_linkedlist.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reverse_linkedlist.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个链表，反转备用节点并在末尾追加。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/reverseAlternateNodes.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向替代节点.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅给定一个节点指针，从链表中删除该节点。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/deleteNode.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除节点.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除整个链表。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/deleteLinkedlist.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除链表.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打印链表的中间节点而不迭代两次。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/printMiddleNode.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打印MiddleNode.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定链表是否是回文。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/listPallindrome.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listPallindrome.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数据插入已排序的链表中。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/insertInASortedLinkedList.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insertInASortedLinkedList.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定两个给定链表的交集（合并）点。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/findIntersectionPointOfLists.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findIntersectionPointOfLists.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/intersection_of_lists.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intersection_of_lists.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克隆一个具有 next 和一个随机指针的链表，空间复杂度 - O(1)。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/cloneListWithRandomPtr.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloneListWithRandomPtr.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/clone_list_with_random_ptr.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone_list_with_random_ptr.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个包含重复项的排序链表，在一次迭代中删除重复项。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/removeDuplicatesFromSortedList.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从排序列表中删除重复项.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Floyd的环路查找算法，检测链表是否包含环路，如果包含环路，则删除环路</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/floyedCycleDetection.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">floyedCycleDetection.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用归并排序对链表进行排序</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/merge_sort.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge_sort.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个单链表 L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; … -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">重新排列列表中的节点（就地），使新形成的列表为： L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-2 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">....</font></font></sub></sub></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/linked_list_problems/rearrange_list.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新排列列表.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-include" class="anchor" aria-hidden="true" tabindex="-1" href="#include"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括</font></font></h3>
<p dir="auto"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Include 包含数据结构和一些算法的单个标头实现。</font></font></p>
<table>
<thead>
<tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据结构/算法</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用宏和算法，如交换、随机数生成</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/generic.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用堆栈实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/stack.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用队列实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/queue.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用列表实施</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/list.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二叉搜索树的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/binarySearchTree.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二叉搜索树.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速排序的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/quickSort.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速排序.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">归并排序的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/mergeSort.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并排序.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择排序的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/selectionSort.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择排序.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冒泡排序的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/bubbleSort.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冒泡排序.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux内核双链表实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/double_linked_list.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双链表.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用图实现（邻接表）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/graph.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/heap_sort.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序.h</font></font></a></td>
</tr>
<tr>
<td align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我自己的字符串库实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/pstring.h"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pstring.h </font></font></a> <a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/include/pstring.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pstring.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-bit-manipulation-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#bit-manipulation-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位操作问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">判断一个数是否是2的幂。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/power_of_2.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">power_of_2.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加两个表示为字符串的二进制数。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/addBin.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addBin.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定给定数字的下一个 2 的幂。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/next_power_of_2.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next_power_of_2.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用位操作确定数字是否是 3 的倍数。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/multiple_of_3.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiple_of_3.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定机器的字节顺序，以相反的字节顺序打印一个数字。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/reverseEndianness.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向字节序.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">求给定数的奇偶性。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/find_parity.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找奇偶校验.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用位操作实现数字与 7 的快速乘法。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/multiply_by_7.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘以7.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反转无符号整数的位（两种方法 - 逐位反转和分而治之）。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/reverseBitsOfAnInteger.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数的反向位.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于确定给定整数中最右边设置位的位置的小函数。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/right_most_set_bit.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">right_most_set_bit.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个数字向量，只有一个数字出现奇数次，求该数字。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/find_odd_one_out.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_odd_one_out.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定两个整数，确定它们的和是否会整数溢出。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/integerOverflow.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数溢出.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数字 A 转换为 B 需要多少位翻转操作。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/countNumberOfBitFlips.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">countNumberOfBitFlips.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定数字 x 和 x 的二进制表示形式的两个位置（从右侧开始），编写一个函数，在给定的两个位置处交换 n 个右位并返回结果。</font><font style="vertical-align: inherit;">还假设两组比特不重叠。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/swapSetOfBits.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换位集.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不使用任何算术运算符将两个数字相加</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/addition_without_operators.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addition_without_operators.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路易丝和理查德玩游戏。</font><font style="vertical-align: inherit;">他们将计数器设置为 N。路易丝获得第一个回合，此后回合交替。</font><font style="vertical-align: inherit;">在游戏中，他们执行以下操作：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果 N 不是 2 的幂，则将计数器减少小于 N 的最大 2 的幂。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果 N 是 2 的幂，则将计数器减少 N 的一半。</font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得到的值就是新的N，再次用于后续操作。当计数器减到1时，即N==1，游戏结束，最后做出有效动作的人获胜。</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定 N，你的任务是找到游戏的获胜者。</font><font style="vertical-align: inherit;">如果他们设置的数字为 1，则理查德获胜，因为轮到路易丝了，而她无法采取行动。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入格式： - 第一行包含一个整数 T，测试用例的数量。</font><font style="vertical-align: inherit;">T 线如下。</font><font style="vertical-align: inherit;">每行包含 N，即计数器中设置的初始数字。</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/counter_game.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数器游戏.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定两个整数是否符号相反。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/check_opposite_signs.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check_opposite_signs.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换给定整数的位置 p 和 q 处的两位。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/swapBits.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换位.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查一个数是否是4的幂。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/bit_manipulation/check_if_power_of_4.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check_if_power_of_4.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-cracking-the-coding-interview-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#cracking-the-coding-interview-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破解编码面试问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-1：第 6 版：编写一个算法来确定字符串是否具有唯一字符。</font><font style="vertical-align: inherit;">我们可以在不使用额外数据结构的情况下做到这一点吗？</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-1-hasUniqueChars.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-1-hasUniqueChars.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-1-hasUniqueChars.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-1-hasUniqueChars.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-2：第 5 版：当您传递一个以 null 结尾的 C 字符串时，反转字符串。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-2-edi5-reverseString.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-2-edi5-reverseString.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-2：第 6 版：给定两个字符串，确定一个字符串是否是另一个字符串的排列。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-2-perm-strings.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-2-perm-strings.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-2-perm-strings.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-2-perm-strings.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-3：第 5 版：编写一个算法来删除字符串中的重复字符。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-3-edi5-removeDuplicates.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-3-edi5-removeDuplicates.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-3：第 6 版：URLify：将字符串中的所有空格替换为“%20”。</font><font style="vertical-align: inherit;">最好就地</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-3-URLify.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-3-URLify.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-4：第 6 版：给定一个字符串，编写一个函数来检查它是否是回文排列。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-4-pallindrome-permutations.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-4-回文排列.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-5：第 6 版：可以对字符串执行三种可能的编辑 - 插入字符、删除字符、替换字符。</font><font style="vertical-align: inherit;">给定两个字符串，确定它们是 1 编辑还是 0 编辑。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-5-one-edit-away.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-5-one-edit-away.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-6：实现一种执行基本字符串压缩的方法。</font><font style="vertical-align: inherit;">示例字符串</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aabcccccaaa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应压缩为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a2b1c5a3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是如果压缩字符串大于原始字符串，则返回原始字符串</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-6-string-compression.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-6-字符串压缩.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题1-7：将矩阵顺时针（&amp;逆时针）旋转90度</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-7-matrix-rotation.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-7-矩阵旋转.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-8：编写一个算法，如果 MxN 矩阵的某个元素为 0，则其整个行和列都设置为 0。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-8-zero-matrix.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-8-零矩阵.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 1-9：给定两个字符串 s1 和 s2，只需调用一个函数来确定 s2 是 s1 的旋转，该函数检查一个字符串是否是另一个字符串的旋转。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/1-9-string-rotation.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-9-字符串旋转.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 2-1：从未排序的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链表</font><font style="vertical-align: inherit;">中删除重复项。</font><font style="vertical-align: inherit;">如果不允许临时缓冲区怎么办？</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-1-remove-dups.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-1-删除-dups.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 2-2：从单链表的最后</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点确定第 k个节点。</font><font style="vertical-align: inherit;">（迭代和递归方法）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-2-kthToLast.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-2-kthToLast.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题2-3：实现删除单链表中间节点的算法</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-3-delete-middle-node.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-3-删除-中间节点.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 2-4：围绕值 x 划分链表，所有小于 x 的节点都位于所有大于等于 x 的节点之前</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-4-partition.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-4-分区.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题 2-5：有两个由链表表示的数字，其中每个节点包含一个数字。</font><font style="vertical-align: inherit;">这些数字以相反的顺序存储，使得 1 的数字位于列表的开头。</font><font style="vertical-align: inherit;">编写一个函数，将两个数字相加并以链表形式返回总和。示例：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入：( 7 --&gt; 1 --&gt; 6 ) + ( 5 --&gt; 9 --&gt; 2 ) 即 617 + 295</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出：( 2 --&gt; 1 --&gt; 9 ) 即 912。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FOLLOW UP ：假设列表按正序存储，重复上述问题。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入：( 6 --&gt; 1 --&gt; 7 ) + ( 2 --&gt; 9 --&gt; 5 ) 即 617 + 295</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出：( 9 --&gt; 1 --&gt; 2 ) 即 912。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归和迭代地实现它。</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-5-add-lists.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-5-添加列表.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题2-6：判断链表是否是回文（2次迭代和1次递归方法）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-6-palindrome.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-6-回文.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题2-7：判断两个单链表是否相交，如果相交，则返回相交节点。</font><font style="vertical-align: inherit;">交集是根据参考而不是值定义的</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-7-intersection.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-7-交叉点.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题2-8：检测链表是否有环，找到环的起始节点并去除环</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/cracking_the_coding_interview_problems/2-8-loop-detection.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-8-循环检测.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-dynamic-programming-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#dynamic-programming-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态规划问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用不同记忆技术的斐波那契</font><font style="vertical-align: inherit;">第 N</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项</font></font></sup><font style="vertical-align: inherit;"></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/fibonacci.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斐波那契.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最长公共子序列问题</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/lcs.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lcs.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/longest_common_subsequence.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最长的_common_subsequence.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大值连续子序列问题</font></font><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki</font></font></a></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/max_subsequence.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大子序列.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加泰罗尼亚数 - 计算具有 n 个键的可能二叉搜索树的数量</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/catalan_number.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加泰罗尼亚语号码.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算 amxn 网格中从源起点 (0, 0) 到目的地 (m-1, n-1) 的唯一路径的数量。</font><font style="vertical-align: inherit;">您只能向下或向右移动。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/unique_paths.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一路径.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0-1 背包问题：假设你是一个小偷，你想偷东西，房间里装满了东西。</font><font style="vertical-align: inherit;">您有一个背包，其最大容量为 W，您希望将其装满，使其价值最大。</font><font style="vertical-align: inherit;">作为一个聪明的小偷，你知道房间里每件物品的重量和价值。</font><font style="vertical-align: inherit;">你会如何装满你的背包，这样你就可以获得最大可能的价值，这样你只能装满容量W。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/dynamic_programming_problems/0_1_knapsack_problem.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0_1_knapsack_problem.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-tree-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#tree-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用队列对树进行迭代级别顺序遍历</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/levelOrderTraversalIterative.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">levelOrderTraversalIterative.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/level_order_tree_traversal_iterative.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">level_order_tree_traversal_iterative.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tree的递归层序遍历</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/levelOrderTraversalRecursive.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">levelOrderTraversalRecursive.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/level_order_tree_traversal_recursive.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">level_order_tree_traversal_recursive.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树的之字形遍历</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/zigZagTraversal.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zigZagTraversal.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/zig_zag_traversal.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zig_zag_traversal.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二叉搜索树中给定节点的前驱和后继</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/predecessorSuccessor.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前驱后继.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定二叉搜索树中两个节点的值，找到最低公共祖先（LCA）。</font><font style="vertical-align: inherit;">假设这两个值都存在于树中。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/lowest-common-ancestor.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低共同祖先.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/lowest_common_ancestor.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低共同祖先.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树（与二叉搜索树不同），找到最低公共祖先（LCA）。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/lowest-common-ancestor-binary-tree.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低共同祖先二元树.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，每行打印出其所有根到叶路径。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/printAllRootToLeafPath.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printAllRootToLeafPath.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">判断一棵树是否是和树。</font><font style="vertical-align: inherit;">SumTree 是二叉树，其中节点的值等于其左子树和右子树中存在的节点之和。</font><font style="vertical-align: inherit;">空树就是SumTree，空树的和可以认为是0。叶子节点也可以认为是SumTree。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/sumTree.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumTree.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将树转换为 sumTree，使得每个节点都是原始树的左子树和右子树的和。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/convert_to_sum_tree.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convert_to_sum_tree.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/convert_to_sum_tree.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convert_to_sum_tree.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将排序数组转换为平衡二叉搜索树。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/sortedArrayToBST.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序数组到BST.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，生成每个垂直列的总和。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/verticalSum.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直求和.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定二叉树和键，具有键的节点存在于树中。</font><font style="vertical-align: inherit;">找到带有key的节点的所有祖先，这里的祖先是从节点到根的直线路径上的节点。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/node_ancestors_in_root_path.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node_ancestors_in_root_path.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定二叉树和键，返回具有键的节点的级别。</font><font style="vertical-align: inherit;">根位于第 1 层，如果树中不存在具有键的节点，则返回 0</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/level_of_node.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点级别.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，找到从根到节点的所有路径，其总和为k。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/k_sum_paths.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k_sum_paths.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，以相反的顺序逐层打印其节点。</font><font style="vertical-align: inherit;">即最后一级的所有节点应首先打印，然后是倒数第二级的节点，依此类推。任何级别的所有节点都应从左到右打印。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/reverseLevelOrderTraversal.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向层序遍历.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以递归和迭代方式反转二叉树。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/invert_a_tree.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反转树.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个二叉搜索树，找到其中给定键的 ceil 和 Floor。</font><font style="vertical-align: inherit;">如果给定的键位于 BST 中，则 Floor 和 ceil 都等于该键，否则 ceil 等于 BST 中的下一个更大的键（如果有），而 Floor 等于 BST 中的上一个更大的键（如果有）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/floor_ceil_bst.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floor_ceil_bst.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找二叉搜索树中的第 k 个最小元素</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/kth_smallest.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kth_smallest.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证给定的二叉树是否是二叉搜索树。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/validate_bst.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">validate_bst.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定二叉搜索树和目标数，如果 BST 中存在两个元素且它们的总和等于给定目标，则返回 true。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/find_target_k.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找目标k.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个非空二叉搜索树和一个目标值，找到 BST 中最接近目标的值。</font><font style="vertical-align: inherit;">另外，要注意目标值是浮点数。</font><font style="vertical-align: inherit;">只有一个最接近目标的唯一值。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/closest_bst_value.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最接近的bst_value.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/closest_bst_value.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最接近的_bst_value.py</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，遍历前序，构造一个包含节点值和括号的字符串输出。</font><font style="vertical-align: inherit;">空节点需要用空括号对“()”表示。</font><font style="vertical-align: inherit;">并且需要省略所有不影响字符串和原始二叉树之间一对一映射关系的空括号对。</font><font style="vertical-align: inherit;">代码文件中的示例</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/tree_problems/string_from_tree.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">string_from_tree.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-string-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#string-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串搜索的 Robin-Karp 算法的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problmes/robinKarpStringMatching.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">robinKarpStringMatching.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到给定字符串的下一个排列，即。</font><font style="vertical-align: inherit;">重新排列给定的字符串，使其成为按字典顺序大于给定字符串的下一个字符串</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problems/next_permutation.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next_permutation.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配Z算法的实现</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problems/z.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自建字符串库的测试用例</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problems/pstring_test.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pstring_test.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取字符串中最后一个单词的长度。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problems/length_of_last_word.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一个单词的长度.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找出两个字符串之间的差异。</font><font style="vertical-align: inherit;">字符串 t 是通过随机打乱字符串 s 生成的，然后在随机位置再添加一个字母。</font><font style="vertical-align: inherit;">确定 t 中不同的字符</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/string_problems/find_difference.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找差异.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-common-data-structure-and-logic-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#common-data-structure-and-logic-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见数据结构和逻辑问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以螺旋顺序打印矩阵的内容</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/matrix_spiral_print.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩阵螺旋打印.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个 M x N 矩阵，将其逆时针旋转 R 次，并显示结果矩阵。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/rotate_matrix.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转矩阵.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数组旋转 r 个元素（向左或向右）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/array_rotation.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组旋转.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个重复/非重复整数数组，确定该数组中的第一个非重复整数</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/first_non_repeating_int.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个非重复整数.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Quantumland中，有n个城市，编号从1到n。</font><font style="vertical-align: inherit;">这里，c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示第 i</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市。</font><font style="vertical-align: inherit;">Quantumland 有 n−1 条道路。</font><font style="vertical-align: inherit;">这里，对于每个 i &lt; n，ci</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i+1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间有一条双向道路。有传言说 Flatland 将攻击 Quantumland，而女王想要保证她的土地安全。</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果 c i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sub><font style="vertical-align: inherit;"><sub><font style="vertical-align: inherit;">+1</font></sub><font style="vertical-align: inherit;">中有警卫，则 c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和 c i+1</font><font style="vertical-align: inherit;">之间的道路是安全的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">女王已经在一些城市安置了一些警卫，但她不确定他们是否足以保证道路安全。</font><font style="vertical-align: inherit;">她想知道需要雇用的最低数量的新警卫。</font><font style="vertical-align: inherit;">有关输入/输出详细信息，请参阅解决方案中的注释。</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/save_quantumland.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">save_quantamland.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个整数 N。找出该数字中恰好能整除 N（余数为 0 的除法）的数字，并显示它们的个数。</font><font style="vertical-align: inherit;">对于 N=24，有 2 位数字（2 和 4）。</font><font style="vertical-align: inherit;">这两个数字都可以整除 24。所以我们的答案是 2。请参阅解决方案文件的标头注释中了解更多详细信息。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/findDigits.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找数字.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用 Caeser Cipher 加密然后解密文本。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/caeser_cipher.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caeser_cipher.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用维吉尼亚密码加密然后解密文本。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/vigenere_cipher.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vigenere_cipher.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高效生成 1 到 N 之间的二进制数。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/n_binary.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_binary.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现电源功能</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/common_ds_algo_problems/power_function.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电源函数.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-math-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#math-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数学问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打印字符串的所有排列。</font><font style="vertical-align: inherit;">示例：ABC 的排列为 ABC、ACB、BCA、BAC、CAB、CBA</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/string_permutations.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串排列.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欧几里得算法找到两个数字的最大公约数。</font><font style="vertical-align: inherit;">（迭代和递归）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/gcd.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcd.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用分而治之的方法实现 pow(x,y)。</font><font style="vertical-align: inherit;">尝试以 O(logn) 实现它</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/pow.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">战俘.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算大数的阶乘，例如 100（它将有 158 位数字）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/factorial_of_large_num.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Factorial_of_large_num.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据在传统移动键盘上输入的数字生成所有可能的单词</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/phone_digits.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电话号码.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定数字的字符串表示形式，从字符串中删除 n 个字符，以使数字表示形式尽可能最低。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/lowest_possible_number.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低可能数.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测一个数字是否是一个快乐的数字。</font><font style="vertical-align: inherit;">如果将数字替换为其数字的平方和的一系列运算最终导致 1，则该数字是快乐数字。如果执行上述操作时处于无限循环中，则该数字不是快乐数字。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/math_problems/happy_number.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">happy_number.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-stack-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#stack-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一系列股票的 n 个每日报价。</font><font style="vertical-align: inherit;">我们需要计算所有 n 天的股票价格跨度。</font><font style="vertical-align: inherit;">第 i 天的跨度定义为股票价格小于或等于第 i 天的最大连续天数。</font><font style="vertical-align: inherit;">对于股票报价 {100, 60, 70, 65, 80, 85}，跨度将为 {1, 1, 2, 1, 4, 5}。</font><font style="vertical-align: inherit;">第 1 天的跨度始终为 1，现在第 2 天的股票价格为 60，并且之前没有一天库存低于 60。因此跨度仍为 1。对于第 3 天，股票定价为 70，因此其跨度是 2，前一天是 60，依此类推。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/stack_problems/stock_span_problem.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stock_span_problem.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个中缀表达式，将其转换为后缀表达式，示例 (A+B)*C --&gt; AB+C*</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/stack_problems/infix_to_postfix.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中缀到后缀.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个仅包含字符 '(', ')', '{', '}', '[' 和 ']' 的字符串，确定输入字符串是否有效。括号必须以正确的顺序结束，“( )”和“()[]{}”均有效，但“(]”和“([)]”无效。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/stack_problems/valid_parenthesis.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效括号.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-sort-and-search-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#sort-and-search-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序和搜索问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个排序向量，返回向量中某个值出现的第一个索引，如果数字不存在，则返回 -1</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/first_occurrence_binary_search.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First_occurrence_binary_search.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找整数数组中的第一个重复元素。</font><font style="vertical-align: inherit;">给定一个整数数组，找到其中的第一个重复元素。</font><font style="vertical-align: inherit;">我们需要找到出现多次且首次出现索引最小的元素。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/firstRepeatingElement.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个重复元素.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个未排序的整数列表，A={a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,…,a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> }，找到它们之间绝对差最小的一对元素？</font><font style="vertical-align: inherit;">如果有多对，则将它们全部找到。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/closest_numbers.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最接近的数字.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个排序数组，确定该数组中固定点的索引。</font><font style="vertical-align: inherit;">如果数组没有定点，则返回 -1。</font><font style="vertical-align: inherit;">当元素的索引与索引相同时，数组具有不动点，即 i == arr[i]，期望时间复杂度 O(logn)</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/fixedPoint.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定点.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">求数组中先递增后递减的最大元素。</font><font style="vertical-align: inherit;">输入：arr[] = {8, 10, 20, 80, 100, 200, 400, 500, 3, 2, 1}，输出：500。数组也可以严格递增或递减。</font><font style="vertical-align: inherit;">预期时间复杂度为 O(logn)。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/findMaximum.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找最大值.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个正整数和/或负整数数组，在数组中找到总和最接近 0 的一对。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/findClosestPairToZero.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findClosestPairToZero.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">艺术家 Numeros 有两个列表 A 和 B，其中 B 是 A 的排列。Numeros 对这些列表感到非常自豪。</font><font style="vertical-align: inherit;">不幸的是，在将它们从一个展览运送到另一个展览时，A 中遗漏了一些号码。你能找到丢失的号码吗？</font><font style="vertical-align: inherit;">笔记：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果某个数字在列表中多次出现，则必须确保该数字在两个列表中出现的频率相同。</font><font style="vertical-align: inherit;">如果不是这种情况，那么它也是一个缺失的数字。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您必须按升序打印所有缺失的数字。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将每个缺失的数字打印一次，即使它缺失多次。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B 中的最大数与最小数之差小于或等于 100。</font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将有四行输入： n - 第一个列表的大小，后面跟着 n 个空格分隔的整数，组成第一个列表。</font><font style="vertical-align: inherit;">m - 第二个列表的大小。</font><font style="vertical-align: inherit;">接下来是 m 个空格分隔的整数，它们构成了第二个列表。</font><font style="vertical-align: inherit;">按升序输出缺失的数字。</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/missingNumbers.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺失数字.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从两个排序数组中找到最接近的一对。</font><font style="vertical-align: inherit;">给定两个排序数组和一个数字 x，找到总和最接近 x 的对，并且该对包含每个数组中的一个元素。</font><font style="vertical-align: inherit;">给定两个数组 ar1[0…m-1] 和 ar2[0..n-1] 和一个数字 x，我们需要找到一对 ar1[i] + ar2[j]，使得 (ar1 [i] + ar2[j] – x) 是最小值。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/closestPairSorted.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClosestPairSorted.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个包含 n 个元素的数组 A，找到三个索引 i、j 和 k，使得 A[i]^2 + A[j]^2 = A[K]^2。</font><font style="vertical-align: inherit;">O(n2) 时间复杂度和 O(1) 空间复杂度</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/squareSum.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平方和.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个大小为 n 的未排序数组 arr[0..n-1]，找到最小长度子数组 arr[s..e]，以便对该子数组进行排序使整个数组排序。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/minLengthUnsortedArray.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minLengthUnsortedArray.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找出算术级数中缺失的数字</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/missingNumber2.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺失号码2.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找出 3 个排序向量中的公共元素</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/commonIn3Arrays.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commonIn3Arrays.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在未排序的数组/向量中查找具有给定总和的所有对</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/find_pairs_with_sum.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_pairs_with_sum.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个数组，找到其中的峰值元素。</font><font style="vertical-align: inherit;">峰值元素是大于其邻居的元素。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/peak_element.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">峰元素.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个不同非负整数的排序数组，找到其中最小的缺失元素。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/smallest_missing.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小缺失.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将向量中的所有零移至末尾</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/sort_search_problems/move_zeros.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move_zeros.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-graph-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#graph-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图的深度优先遍历</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/dfsDemo.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dfsDemo.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图的广度优先遍历</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/bfsDemo.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bfsDemo.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用 Dijkstra 算法计算从起始位置（节点 S）到图中所有其他节点的最短距离。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/dijkstra-shortest-reach.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijkstra-最短到达.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用 Prim 算法计算给定图的最小生成树的总权重（形成 MST 的边的权重之和）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/primsMST.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primsMST.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用 Kruskal 算法打印给定图的最小生成树 ( MST )。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/kruskalMST.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克鲁斯卡尔MST.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个程序，为每个字符生成霍夫曼编码作为表格。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/greedy_problems/huffman_encoding.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈夫曼编码.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在包含字母的 2D 板上搜索给定单词。</font><font style="vertical-align: inherit;">可以通过顺序遍历相邻的水平或垂直单元来构造单词。</font><font style="vertical-align: inherit;">在组成单词的序列中，同一位置上的字母不能使用多次。</font><font style="vertical-align: inherit;">（查看文件顶部的示例。）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/grid_word_search.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grid_word_search.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定 2D 屏幕、像素的位置和要填充的颜色的新值，用新颜色替换像素的颜色和所有相邻（上、下、左、右）相同颜色的像素。</font><font style="vertical-align: inherit;">这与 MS-PAINT 中的区域洪水填充（记住桶符号）相同。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/graph_problems/flood_fill.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">洪水填充.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-greedy-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#greedy-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">贪心问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定两个整数数组 A 和 B，每个数组包含 N 个整数。</font><font style="vertical-align: inherit;">您可以自由排列数组中元素的顺序。</font><font style="vertical-align: inherit;">A 和 B 是否存在可能的排列 A', B'，使得</font><font style="vertical-align: inherit;">对于所有 i ，A' </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +B' </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i ≥ K，其中 A' </font></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示</font><font style="vertical-align: inherit;">数组 A' 中的第 i</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素，B' </font></font></sup><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示</font><font style="vertical-align: inherit;">数组 B' 中的</font><font style="vertical-align: inherit;">第 i</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素。</font></font></sup><font style="vertical-align: inherit;"></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/greedy_problems/two_arrays.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个数组.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约翰正在接受命令。</font><font style="vertical-align: inherit;">第 i</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">订单是由第 i</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户在 t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间下的，需要 d </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间才能处理。</font><font style="vertical-align: inherit;">客户收到订单的顺序是什么？</font><font style="vertical-align: inherit;">（请参阅解决方案评论中的更多详细信息）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/greedy_problems/orders_order.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">订单_订单.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-backtracking-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#backtracking-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回溯问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您将获得一个数字字符串（例如“1234”、“567”等），根据我们在电话/移动拨号盘上看到的映射，提供我们可以从该数字字符串生成的所有可能的字母组合。</font><font style="vertical-align: inherit;">如果您在老式手机中输入过短信，您就会知道。</font><font style="vertical-align: inherit;">例如，“1”映射到“abc”，2 映射到“def”。</font><font style="vertical-align: inherit;">您可以参考图片</font></font><a href="http://techotv.com/wp-content/uploads/2013/03/Lumia-620-dial-pad-screen-1.jpg" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例：“34”将给出输出：{“dg”，“dh”，“di”，“eg”，“eh”，“ei”，“fg”，“fh”，“fi”}</font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，结果集中的顺序并不重要。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/backtracking_problems/dialpad_combinations.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dialpad_combinations.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现通配符模式处理并支持“?” </font><font style="vertical-align: inherit;">&amp;' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'。</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'？' </font><font style="vertical-align: inherit;">匹配任何单个字符。</font></font></li></ul></em><ul dir="auto"><em></em><li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ' 匹配任何字符序列。</font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">查看文件中的示例以了解更多详细信息。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/backtracking_problems/wild_card_matching.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通配符匹配.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个 2D 棋盘和字典中的单词列表，从列表中找到棋盘上所有可能的单词。</font><font style="vertical-align: inherit;">（检查解决方案中的示例）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/backtracking_problems/word_search.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word_search.cpp</font></font></a></td>
</tr>
</tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-leet-code-problems" class="anchor" aria-hidden="true" tabindex="-1" href="#leet-code-problems"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leet代码问题</font></font></h3>
<table>
<thead>
<tr>
<th align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个没有重复项的排序整数数组，返回其范围的摘要。</font><font style="vertical-align: inherit;">例如，给定 [0,1,2,4,5,7]，返回 ["0-&gt;2","4-&gt;5","7"]。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/summary_ranges.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要_范围.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个二维矩阵，具有以下属性</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每行中的整数从左到右升序排序。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每列中的整数从上到下按升序排序。</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/search2DII.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索2DII.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个未排序的整数数组，找到第一个缺失的正整数。示例：[1,2,0] 应返回 3，[3,4,-1,1] 应返回 2。预期时间复杂度 O(n) 且解决方案应使用恒定空间</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/firstMissingPositiveNum.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个缺失正数.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个未排序的整数数组，找到最长连续元素序列的长度。</font><font style="vertical-align: inherit;">例如：给定 [100, 4, 200, 1, 3, 2]。</font><font style="vertical-align: inherit;">最长的连续元素序列是[1,2,3,4]。</font><font style="vertical-align: inherit;">返回其长度：4。算法应以 O(n) 复杂度运行。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/longestConsecutiveSeq.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最长连续Seq.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定两个排序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 作为一个排序数组。您可以假设 nums1 有足够的空间（大小大于或等于 m + n）来容纳 nums2 中的其他元素。</font><font style="vertical-align: inherit;">nums1和nums2中初始化的元素数量分别为m和n。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/mergeArrays.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并数组.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个非负整数数组，您最初位于数组的第一个索引处。</font><font style="vertical-align: inherit;">数组中的每个元素代表您在该位置的最大跳跃长度。</font><font style="vertical-align: inherit;">确定您是否能够到达最后一个索引。</font><font style="vertical-align: inherit;">例如：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A = [2,3,1,1,4]，返回 true。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A = [3,2,1,0,4]，返回 false。</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/jumpGame.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跳跃游戏.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个正整数，返回 Excel 工作表中显示的相应列标题。</font><font style="vertical-align: inherit;">例如 1 -&gt; A、2 -&gt; B、...26 -&gt; Z、27 -&gt; AA、28 -&gt; AB、...705 -&gt; AAC</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/excelColSheetTitle.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelColSheetTitle.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个数组 nums，编写一个函数将所有 0 移至其末尾，同时保持非零元素的相对顺序。</font><font style="vertical-align: inherit;">例如，给定 nums = [0, 1, 0, 3, 12]，调用函数后，nums 应为 [1, 3, 12, 0, 0]。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/moveZeroes.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moveZeroes.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个整数数组，查找该数组是否包含任何重复项。</font><font style="vertical-align: inherit;">如果任何值在数组中至少出现两次，函数应返回 true；如果每个元素都不同，则函数应返回 false。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/containsDuplicate.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含重复的.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个列表，将列表向右旋转 k 个位置，其中 k 为非负数。</font><font style="vertical-align: inherit;">例如：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 且 k = 2，返回 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/rotateList.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转列表.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定两个单词 word1 和 word2，找到将 word1 转换为 word2 所需的最少步骤数。</font><font style="vertical-align: inherit;">（每次操作计为1步。）。</font><font style="vertical-align: inherit;">允许对单词进行以下 3 种操作：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入一个字符</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除一个字符。</font></font></li></ul><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换一个字符</font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/editDistance.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑距离.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一棵二叉树，填充每个下一个指针以指向其下一个右侧节点。</font><font style="vertical-align: inherit;">如果没有下一个右节点，则下一个指针应设置为 NULL。</font><font style="vertical-align: inherit;">最初，所有下一个指针都设置为 NULL。您只能使用恒定的额外空间。您可以假设它是一个完美的二叉树（即，所有叶子都在同一级别，并且每个父节点都有两个子节点）。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/connectNextPointers.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接下一个指针.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定 n 对括号，编写一个函数来生成格式正确的括号的所有组合。</font><font style="vertical-align: inherit;">例如，给定 n = 3，解集为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“((()))”、“(()())”、“(())()”、“()(())”、“( )()()"</font></font></em></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/generate_parenthesis.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成括号.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个包含从 0, 1, 2, ..., n 中选取的 n 个不同数字的数组，找到该数组中缺少的一个。例如，给定 nums = [0, 1, 3] 返回 2。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/missing_number.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失踪号码.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设已排序的数组在您事先未知的某个枢轴处旋转。</font><font style="vertical-align: inherit;">（即，0 1 2 4 5 6 7 可能变为 4 5 6 7 0 1 2）。</font><font style="vertical-align: inherit;">求最小元素。</font><font style="vertical-align: inherit;">您可以假设数组中不存在重复项。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/find_min_rotated.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_min_rotated.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个包含 n 个整数的数组 S，在 S 中找到三个整数，使得总和最接近给定数字 target。</font><font style="vertical-align: inherit;">返回三个整数的总和。</font><font style="vertical-align: inherit;">您可以假设每个输入都有一个解决方案。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/threeSumClosest.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreeSumClosest.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定 n 个非负整数 a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中每个表示坐标 (i, a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) 处的一个点。</font><font style="vertical-align: inherit;">绘制 n 条垂直线，使得线 i 的两个端点位于 (i, a </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) 和 (i, 0) 处。</font><font style="vertical-align: inherit;">找到两条线，它们与 x 轴一起形成一个容器，使得该容器包含最多的水。</font><font style="vertical-align: inherit;">注意：容器不得倾斜。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/maxArea.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大面积.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个仅包含 0-9 数字的二叉树，每个根到叶路径都可以代表一个数字。</font><font style="vertical-align: inherit;">一个例子是根到叶子路径 1-&gt;2-&gt;3，它代表数字 123。求所有根到叶子数字的总和。</font><font style="vertical-align: inherit;">解决方案评论中的示例</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/sumRootToLeafNumbers.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumRootToLeafNumbers.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设您有一个数组，其中第 i 个元素是给定股票在第 i 天的价格。</font><font style="vertical-align: inherit;">如果您最多只被允许完成一笔交易（即买入一股并卖出一股股票），请设计一种算法来找到最大利润。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/maxProfitStock.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大利润股票.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定充满非负数的 amxn 网格，找到一条从左上角到右下角的路径，该路径最小化沿其路径的所有数字的总和。</font><font style="vertical-align: inherit;">注意：在任何时间点您只能向下或向右移动。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/minPath.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小路径.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算小于非负数 n 的素数的数量。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/countPrimes.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">质数计数.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设只能使用从 1 到 9 的数字，并且每个组合都应该是一组唯一的数字，请找出 k 个数字的所有可能组合，总和为数字 n。</font><font style="vertical-align: inherit;">确保集合中的数字按升序排序。</font><font style="vertical-align: inherit;">示例：对于 k = 3, n = 9 结果将是 [[1,2,6], [1,3,5], [2,3,4]]，类似地对于 k = 3, n = 7，结果将是[[1,2,4]]。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/combinationSum3.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组合Sum3.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个非负整数 num，重复将其所有数字相加，直到结果只有一位数字。</font><font style="vertical-align: inherit;">例如：给定 num = 38，过程如下：3 + 8 = 11, 1 + 1 = 2。由于 2 只有一位数字，因此返回它。</font><font style="vertical-align: inherit;">跟进：你能在 O(1) 运行时中不使用任何循环/递归来完成它吗？</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/addDigits.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加数字.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个单元格值为 0 或 1 的矩阵。找到从 (a1, b1) 到 (a2, b2) 的最短路径的长度，这样路径只能通过值为 1 的单元格构建，并且只能在 4 中行驶可能的方向，即左、右、上、下。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/shortest_path_maze.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最短路径迷宫.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个整数之间的汉明距离是对应位不同的位置的数量。</font><font style="vertical-align: inherit;">给定两个整数 x 和 y，计算汉明距离。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/hamming_distance.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汉明距离.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定两棵二叉树，想象一下，当您将其中一棵树覆盖另一棵时，两棵树的某些节点重叠，而其他节点则不重叠。</font><font style="vertical-align: inherit;">您需要将它们合并到一个新的二叉树中。</font><font style="vertical-align: inherit;">合并规则是，如果两个节点重叠，则将节点值相加作为合并节点的新值。</font><font style="vertical-align: inherit;">否则，NOT null 节点将被用作新树的节点。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/merge_trees.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge_trees.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写一个函数，将字符串作为输入并仅反转字符串的元音。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/reverse_vowels.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向元音.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个字符串，根据字符出现的频率将其按降序排序。例如：</font></font><ul dir="auto"><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入：cccbbbbbaa 输出：bbbcccaa</font></font></li></ul></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/sortCharByFrequency.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按频率排序Char.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除 Self 之外的数组的乘积。</font><font style="vertical-align: inherit;">给定一个由 n 个整数组成的数组，其中 n &gt; 1，nums，返回一个数组输出，使得 output[i] 等于 nums 中除 nums[i] 之外的所有元素的乘积。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/product_except_self.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">产品_例外_自我.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个已排序的数组，就地删除重复项并返回新的长度。</font><font style="vertical-align: inherit;">数组中超出唯一元素大小的内容并不重要。</font><font style="vertical-align: inherit;">预期 O(1) 空间复杂度和 O(n) 时间复杂度。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/remove_duplicates.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除重复项.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算网格中岛屿的数量。</font><font style="vertical-align: inherit;">给定一个网格，1表示陆地，0表示水体，确定岛屿的数量（更多详细信息请参见问题评论）</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/count_islands.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">岛屿计数.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从数据流中查找中位数。</font><font style="vertical-align: inherit;">设计一个数据结构，支持 addNum 将数字添加到流中，并 findMedian 返回目前为止看到的当前数字的中位数。</font><font style="vertical-align: inherit;">另外，如果数字个数为偶数，则返回中间两个元素的平均值，否则返回中位数。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/median_stream.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中值流.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除最少数量的无效括号以使输入字符串有效。</font><font style="vertical-align: inherit;">返回所有可能的结果。</font><font style="vertical-align: inherit;">注意：输入字符串可能包含除括号 ( 和 ) 之外的字母</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/remove_invalid_parenthesis.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除_无效_括号.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个数组和一个值，就地删除该值的所有实例并返回新的长度。</font><font style="vertical-align: inherit;">不要为另一个数组分配额外的空间，必须通过使用 O(1) 额外内存就地修改输入数组来完成此操作。</font><font style="vertical-align: inherit;">元素的顺序可以更改。</font><font style="vertical-align: inherit;">在新长度之外留下什么并不重要。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/remove_element.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除元素.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到两个数组/向量的交集，给定两个向量找到它们相互作用的结果。</font><font style="vertical-align: inherit;">结果应仅包含唯一字符并且可以按任何顺序</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/intersection_of_array.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组的交集.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个模式和一个字符串 str，查找 str 是否遵循相同的模式。</font><font style="vertical-align: inherit;">这里follow表示完全匹配，即pattern中的字母和str中的非空单词之间存在双射。</font><font style="vertical-align: inherit;">例子：</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式=“abba”，str=“狗猫猫狗”应该返回true。</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pattern =“abba”，str =“狗猫猫鱼”应该返回 false。</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式=“aaaa”，str=“狗猫猫狗”应该返回false。</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pattern =“abba”，str =“dogdogdogdog”应该返回 false。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/word_pattern.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word_pattern.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为您提供了一个数字向量，其中每个数字代表</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">股票第 i 天的价格。</font><font style="vertical-align: inherit;">如果您被允许只完成</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每天一笔交易（即买入一只股票并卖出一只股票），设计</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寻找最大利润的算法。</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/best_time_to_buy_sell.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳购买时间.cpp</font></font></a></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定一个句子，反转句子中每个单词中的字符顺序，同时仍然保留空格和初始单词顺序。</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子：</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入：她喜欢巧克力</font></font></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出：ehs sevol etalochoc</font></font></td>
<td align="center"><a href="https://github.com/yuanzhongqiao/algorithms_and_data_structures/blob/master/leet_code_problems/reverse_words.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反向单词.cpp</font></font></a></td>
</tr>
</tbody>
</table>
</article></div>
